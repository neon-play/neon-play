<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NeonAnime Hub â€” Series</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Main CSS -->
  <link rel="stylesheet" href="css/style.css">

  <!-- Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

</head>
<body data-target="series">

  <!-- ===== HEADER / NAVBAR ===== -->
  <header class="navbar">

    <div class="menu-icon" id="menuBtn" style="margin-left:6px;">
      <span></span>
      <span></span>
      <span></span>
    </div>

    <h1 class="site-title" style="margin:0 auto;">
      NEON<span>ANIME</span> HUB
    </h1>

  </header>

  <!-- ===== SEARCH BAR ===== -->
  <section class="search-section">

    <!-- wrapper centers the bar (uses existing CSS) -->
    <div class="search-wrapper">
      <!-- keep .search-box for JS, add .search-bar so CSS applies -->
      <div class="search-box search-bar">
        <i class="material-icons">search</i>
        <input type="text" placeholder="Search for anime..." />
      </div>
    </div>

    <!-- result panel (styled by CSS). results-inner keeps id used by JS. -->
    <div class="search-result-panel" id="searchResultPanel" aria-hidden="true">
      <div class="results-inner" id="liveSearchResults"></div>
      <div class="no-results" style="display:none;">No results found.</div>
    </div>

  </section>

  <!-- ===== FILTER BAR ===== -->
  <section class="filter-bar">

    <div class="sort-box">
      <label for="sortSelect">Sort by:</label>
      <select id="sortSelect">
        <option value="latest">Latest First</option>
        <option value="oldest">Oldest First</option>
        <option value="az">A - Z</option>
        <option value="za">Z - A</option>
      </select>
    </div>

  </section>
  <!-- ===== SLIDE MENU ===== -->
  <aside class="side-menu" id="sideMenu">

    <div class="menu-header">
      <h2>Menu</h2>
    </div>

    <ul class="menu-list">
      <li><a href="index.html">ğŸ  Home</a></li>
      <li><a href="movies.html">ğŸ¬ Movies</a></li>
      <li><a href="series.html">ğŸ“º Series</a></li>
      <li><a href="genres.html">ğŸ­ Genres</a></li>
    </ul>

  </aside>

  <!-- ===== MAIN CONTENT ===== -->
  <main>

    <section class="content-section">

      <div class="section-header">
        <h2>Series</h2>
      </div>

      <!-- IMPORTANT: keep the same grid id ("movieGrid") so details.js can target it unchanged -->
      <div class="grid-container" id="movieGrid">
        <!-- Cards injected via js/details.js (shim forces only series items through) -->
      </div>
      <button class="load-more-btn" id="loadMoreBtn">Load More Series</button>
    </section>

  </main>

  <!-- ===== FOOTER ===== -->
  <footer class="footer">
    <p>Â© 2026 NeonAnime Hub</p>
  </footer>

  <!-- ===== Fetch shim: intercept data/anime.json and return only SERIES =====
       This runs BEFORE details.js so the existing details.js can be used unchanged.
       It:
         - captures the original fetch
         - when the request is for data/anime.json, extracts only items that look like series
         - converts those series items to have type "Movie" so details.js (which filters for movie-like items)
           will include them; other movie items are excluded
  -->
  <script>
  (function(){
    // Only enable on the series page
    if (!document.body || document.body.getAttribute('data-target') !== 'series') return;

    const origFetch = window.fetch.bind(window);
    window.fetch = function(resource, init){
      // detect string URL (also handle Request object)
      const url = (typeof resource === 'string') ? resource : (resource && resource.url) ? resource.url : '';
      if (url && url.includes('data/anime.json')) {
        // fetch original and transform JSON payload
        return origFetch(resource, init).then(res => {
          // clone and parse JSON (safe since we don't forward original Response)
          return res.clone().json().then(rawData => {

            // helper: identify series-like item
            function isSeriesItem(it){
              if (!it || typeof it !== 'object') return false;
              const check = prop => !!prop && /series/i.test(String(prop));
              return check(it.type) || check(it.category) || check(it.format) || check(it.media) || check(it.section) ||
                     // sometimes 'Series' is implied by 'episodes' or 'seasons'
                     (it.episodes !== undefined) || (it.seasons !== undefined);
            }

            // helper: normalize an item (ensure it has an image/title)
            function normalize(it){
              if (!it) return null;
              // prefer title / name
              if (!it.title && it.name) it.title = it.name;
              // minimal fallbacks for details.js
              if (!it.image && (it.poster || it.cover || it.thumbnail)) it.image = it.poster || it.cover || it.thumbnail;
              return it;
            }

            // collect series items from different shapes of JSON
            let collected = [];

            if (Array.isArray(rawData)) {
              collected = rawData.filter(isSeriesItem).map(normalize).filter(Boolean);
            } else if (rawData && typeof rawData === 'object') {
              // common arrays inside object
              const arraysToCheck = [];
              if (Array.isArray(rawData.series)) arraysToCheck.push(...rawData.series);
              if (Array.isArray(rawData.anime)) arraysToCheck.push(...rawData.anime);
              if (Array.isArray(rawData.items)) arraysToCheck.push(...rawData.items);
              if (Array.isArray(rawData.results)) arraysToCheck.push(...rawData.results);
              if (Array.isArray(rawData.movies)) arraysToCheck.push(...rawData.movies);

              if (arraysToCheck.length) {
                collected = arraysToCheck.filter(isSeriesItem).map(normalize).filter(Boolean);
              } else {
                // fallback: check nested arrays anywhere
                for (const v of Object.values(rawData)) {
                  if (Array.isArray(v)) {
                    collected.push(...v.filter(isSeriesItem).map(normalize).filter(Boolean));
                  }
                }
                // final fallback: check top-level object values that look like items
                if (!collected.length) {
                  const maybe = Object.values(rawData).filter(v => v && typeof v === 'object' && (v.title || v.name) && (v.image || v.poster || v.cover));
                  collected = maybe.filter(isSeriesItem).map(normalize).filter(Boolean);
                }
              }
            }

            // convert series items to look like "movies" for details.js filtering:
            // details.js looks for items whose type/category/format/media include "movie".
            // We set type = "Movie" for each series item so details.js will include them.
            const transformed = collected.map(it => {
              if (it && typeof it === 'object') {
                it.type = 'Movie';
              }
              return it;
            });

            // Return an array of transformed items as the JSON response (details.js accepts arrays)
            return new Response(JSON.stringify(transformed), {
              status: 200,
              headers: { 'Content-Type': 'application/json' }
            });
          });
        });
      }

      // other fetches pass through unchanged
      return origFetch(resource, init);
    };
  })();
  </script>

  <!-- ===== JS (unchanged) ===== -->
  <script src="js/details.js"></script>
<script src="js/bardesign.js"></script>
  <!-- accessibility mirror / small page tweaks (matches movies.html but adjusts labels) -->
  <script>
    // ensure search panel aria toggles for accessibility when JS shows results
    (function(){
      const searchInput = document.querySelector('.search-box input');
      const searchPanel = document.getElementById('searchResultPanel');
      const liveResults = document.getElementById('liveSearchResults');

      const obs = new MutationObserver(() => {
        if (!searchPanel) return;
        const visible = liveResults && window.getComputedStyle(liveResults).display !== 'none' && liveResults.children.length;
        if (visible) {
          searchPanel.classList.add('active');
          searchPanel.setAttribute('aria-hidden', 'false');
        } else {
          searchPanel.classList.remove('active');
          searchPanel.setAttribute('aria-hidden', 'true');
        }
      });
      if (liveResults) obs.observe(liveResults, { childList: true, attributes: true, attributeFilter: ['style'] });
    })();

    // cosmetic: ensure header/title/button show "Series"
    document.addEventListener('DOMContentLoaded', () => {
      const hdr = document.querySelector('.section-header h2');
      if (hdr) hdr.textContent = 'Series';
      const load = document.getElementById('loadMoreBtn');
      if (load) load.textContent = 'Load More Series';
    });
  </script>

</body>
</html>
